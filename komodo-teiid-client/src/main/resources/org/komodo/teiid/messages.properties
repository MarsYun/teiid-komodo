Error.UnsupportedTeiid = The teiid version {0} is not supported
Error.UnsupportedStorageType = The storage type {0} is not supported

TeiidService.NotAJcrNode=Conversion requires parent to be an instance of javax.jcr.Node
TeiidInstance.versionFailure = Failed to determine teiid version of this host {0}
TeiidInstance.parentNotStartedMessage = The host {0} is not available
TeiidInstance.reconnectErrorMsg = Cannot establish a connection to the Teiid instance {0}.
TeiidInstance.noSuchField = Cannot retrieve the jboss extension field {0}
TeiidInstance.buildOperationFailure = The request operation {0} failed construction
TeiidInstance.requestDriverFailure = The request to retrieve the data source drivers failed: '{0}'
TeiidInstance.requestTeiidVersionFailure = The request to retrieve the teiid runtime version failed

ExecutionAdmin.mergeVdbUnsupported = This method is no longer supported and is only provided for backward compatibility with Teiid 7.7.1
ExecutionAdmin.dynamicVdbInvalidName = The supplied Dynamic VDB deployment name "{0}" does not end with "vdb.xml"
ExecutionAdmin.jarDeploymentJarNotFound = The driver jar was not found: "{0}"
ExecutionAdmin.jarDeploymentFailed = The driver jar deployment failed: "{0}"
ExecutionAdmin.jarDeploymentJarNotReadable = The driver jar is not readable: "{0}"
ExecutionAdmin.jdbcSourceForClassNameNotFound = JDBC Source for Driver class {0} was not found on teiid instance {1}
ExecutionAdmin.dataSourceTypeDoesNotExist = Data Source Type {0} does not exist on teiid instance {1}
ExecutionAdmin.errorCreatingDataSource = Data Source {0} could not be created for type {1}
ExecutionAdmin.invalidPropertyValue = The value "{0}" is not valid for property "{1}."
ExecutionAdmin.cannotConnectToServer = Unable to establish connection to teiid instance "{0}"
ExecutionAdmin.instanceDeployUndeployProblemPingingTeiidJdbc = Unable to establish a jdbc connection to teiid instance "{0}"
ExecutionAdmin.invalidPropertyEditorConstrainedValue = "{0}" is not a valid. Must be one of the following: {1}
ExecutionAdmin.invalidPropertyEditorValue = "{0}" is not a valid {1} value
ExecutionAdmin.invalidNullPropertyValue = The property "{0}" must have a value.
ExecutionAdmin.missingPropertyDefinition = No property definition found for property "{0}"
ExecutionAdmin.unknownPropertyType = Property "{0}" has an unknown type of "{1}"
ExecutionAdmin.connectorDetailedName = {0} : {1}
ExecutionAdmin.failedToGetDriverMappings = Failed to get installed driver mappings for request driver "{0}".
ExecutionAdmin.cannotLoadDriverClass = Server cannot load the driver class "{0}"
ExecutionAdmin.admin_conn_closed = The Admin connection has been closed.
ExecutionAdmin.invalid_parameter = The user parameter may not be null or empty.
ExecutionAdmin.noParentServer = The teiid instance {0} lacks a valid parent server
ExecutionAdmin.refreshVdbException = An exception occurred while waiting for the {0} vdb to refresh

TeiidVdb.onlySupportingDynamicVdbs = Only supporting xml-based dynamic vdbs

TeiidURL.invalid_format=The required socket url format is mm[s]://server1:port1[,server2:port2]
TeiidURL.invalid_ipv6_hostport=The IPv6 host:port ''{0}'' is not valid. {1}
TeiidURL.invalid_hostport=The host:port ''{0}'' is not valid. {1}
TeiidURL.non_numeric_port=The port ''{0}'' is a nonnumeric value.
TeiidURL.port_out_of_range=The port ''{0}'' is out of range.

Socket.keystore_not_found=Key store ''{0}'' was not found.
Socket.alias_no_key_entry=The SSL keystore configured does not contain certificate with alias {0}
Socket.anon_not_available=The anonymous cipher suite TLS_DH_anon_WITH_AES_128_CBC_SHA could not be added.  Anonymous SSL connections will fail.

GSS.client_prop_missing=Client URL connection property missing "{0}". Please add the property to connection URL.
GSS.ambigious_gss_selection=Either configure "java.security.krb5.conf" property or combination of "java.security.krb5.realm" and "java.security.krb5.kdc" properties. Not both.
GSS.no_gss_selection=No KRB5 configuration found. Either configure "java.security.krb5.conf" property or combination of "java.security.krb5.realm" and "java.security.krb5.kdc" properties.
GSS.system_prop_missing=System property "{0}" missing, please add using D option on the VM startup script.
GSS.gss_auth_failed=GSS authentication failed
GSS.no_krb_ticket=No cached kerberos ticket found and/or no password supplied

JDBC.Connection_success=The JDBC Driver successfully obtained a connection.
JDBC.continuous=Continuous queries are not supported over socket connections.
JDBC.DataTypeTransformer_blob_too_big=The blob value is too large for the max supported length of 2147483647 bytes
JDBC.DataTypeTransformer_Err_converting=Unable to transform the column value {0} to a {1}.
JDBC.DeferredMetadataProvider_Invalid_data=Invalid data for DeferredMetadataProvider: {0}, {1}
JDBC.Err_registering=JDBC driver could not be registered with the DriverManager: {0}.
JDBC.forward_only_resultset=Continuous queries must be forward only and return a result set.
JDBC.Method_not_supported=This method is not supported.
JDBC.MMCallableStatement_Param_not_found=Parameter {0} was not found.
JDBC.MMConnection_Cant_use_closed_connection=Cannot perform operations on a closed connection.
JDBC.MMConnection_Commit_success=Successfully committed transactions on all open statements on this connection.
JDBC.MMConnection_Concurrency_type_not_supported=Concurrency type {0} is not supported.
JDBC.MMConnection_Connection_close_success=Connection successfully closed.
JDBC.MMConnection_Err_closing_stmts=Error trying to close statements on this connection.
JDBC.MMConnection_Err_connection_close=Error trying to close driver connection: {0}
JDBC.MMConnection_Rollback_success=Successfully rolled back transactions on all open statements on this connection.
JDBC.MMConnection_Scrollable_type_not_supported=Scrollable type {0} is not supported.
JDBC.MMConnection_Session_success=Successfully obtained a session.
JDBC.MMConnection_SQL_cannot_be_null=SQL cannot be null for CallableStatement or PreparedStatement.
JDBC.MMDatabaseMetadata_Best_row_sucess=Successfully obtained best row identifier information for the table {0}.
JDBC.MMDatabaseMetadata_Catalog_success=Catalog metadata info successfully obtained for this connection.
JDBC.MMDatabaseMetadata_Err_getting_primary_keys=Error trying to get metadata information about primary/foreign keys.
JDBC.MMDatabaseMetadata_getCols_error=Error trying to get metadata info for the columns that match {0} present in the tables that match {1}  {2}.
JDBC.MMDatabaseMetadata_getCols_success=Successfully obtained metadata information for the columns that match {0} in table/s whose names match {1}.
JDBC.MMDatabaseMetadata_getCrossRef_error=Error trying to access metadata information about CrossReferences between the table {0} and the table {1}  {2}.
JDBC.MMDatabaseMetadata_getCrossRef_success=Successfully obtained cross reference information between the primaryKey table {0} and foreignKey table {1}.
JDBC.MMDatabaseMetadata_getExpKey_error=Error trying to access metadata information about keys exported by {0}  {1}.
JDBC.MMDatabaseMetadata_getExpKey_success=Successfully obtained exported key information for the table {0}.
JDBC.MMDatabaseMetadata_getImpKey_error=Error trying to access metadata information about keys imported by {0}  {1}.
JDBC.MMDatabaseMetadata_getImpKey_success=Successfully obtained imported key information for the table {0}.
JDBC.MMDatabaseMetadata_getIndex_error=Error trying to get metadata information for indexes present on the table {0}  {1}.
JDBC.MMDatabaseMetadata_getIndex_success=Successfully obtained index information for the table {0}.
JDBC.MMDatabaseMetadata_getPrimaryKey_error=Error trying to get metadata information for primary keys present in the table {0}  {1}.
JDBC.MMDatabaseMetadata_getPrimaryKey_success=Sucessfully obtained primary key metadata info for this connection.
JDBC.MMDatabaseMetadata_getProcCol_error=Error trying to get metadata information for procedure column  whose name matches {0}  {1}.
JDBC.MMDatabaseMetadata_getProcCol_success=Successfully obtained metadata info for the procedure column matching {0} in the procedure whose name matches {1}.
JDBC.MMDatabaseMetadata_getProc_error=Error trying to get metadata information for procedure name like {0}  {1}.
JDBC.MMDatabaseMetadata_getProc_success=Successfully obtained metadata information for the procedure whose name matches {0}.
JDBC.MMDatabaseMetadata_getRefKey_success=Successfully obtained key information on this connection.
JDBC.MMDatabaseMetadata_getschema_error=Error trying to obtain schema metadata info on this connection: {0}.
JDBC.MMDatabaseMetadata_getschema_success=Schema metadata info successfully obtained for this connection.
JDBC.MMDatabaseMetadata_getTable_error=Error trying to obtain metadata information for the tables that match {0}: {1}.
JDBC.MMDatabaseMetadata_getTable_success=Successfully obtained metadata information for the table names that match {0}.
JDBC.MMDatabaseMetadata_getTableType_success=Successfully obtained metadata information for the table types.
JDBC.MMDatabaseMetadata_getTypes_success=Successfully obtained metadata info for supported data types.
JDBC.MMDatabaseMetadata_getVersionCols_success=Successfully obtained version column information for this connection.
JDBC.MMPreparedStatement_Err_prep_sql=Error preparing sql for MMPreparedStatement as the sql is null.
JDBC.MMPreparedStatement_Invalid_param_index=The index of a parameter must be a positive integer.
JDBC.MMResultSet_cannot_convert_to_binary_stream=Cannot convert to binary stream
JDBC.MMResultSet_Cant_call_closed_resultset=Error trying to operate on a closed ResultSet object.
JDBC.MMResultsImpl_Col_doesnt_exist=Column name "{0}" does not exist.
JDBC.MMStatement_Bad_timeout_value=Invalid timeout value supplied. Valid range is greater than or equal to zero.
JDBC.MMStatement_Close_stmt_success=Statement closed successfully.
JDBC.MMStatement_Error_timing_out=Error timing out.
JDBC.MMStatement_Invalid_During_Transaction=Call to method {0} not valid during a transaction.
JDBC.MMStatement_Invalid_fetch_size=Fetch size should always be a value of 0 <= fetch size <= max rows.
JDBC.MMStatement_Invalid_field_size=Invalid MaxFieldSize {0}
JDBC.MMStatement_Stmt_closed=Unable to perform operations on an already closed statement.
JDBC.MMStatement_Success_query=Successfully executed a query {0} and obtained results
JDBC.MMStatement_Timeout_before_complete=Operation timed out before completion.
JDBC.MMStatement_Timeout_ocurred_in_Statement=Timeout occurred in Statement.
JDBC.MMXAConnection_rolling_back_error=Error while rolling back transaction.
JDBC.MMXAConnection_rolling_back=rolling back transaction.
JDBC.PlanNode_unexpected_element=Unexpected Element {0} encountered, expecting one of {1}
JDBC.ResultsImpl_Invalid_col_index=Column index {0} is invalid. Index must be >= 1 and <= column count.
JDBC.ResultsImpl_Op_invalid_fwd_only=This operation cannot be executed on TYPE_FORWARD_ONLY ResultSets.
JDBC.ResultsImpl_The_cursor_is_not_on_a_valid_row_1=The cursor is not on a valid row.
JDBC.StatementImpl_set_result_set=SET does not return a result set.
JDBC.StatementImpl_show_update_count=SHOW does not return an update count
JDBC.StaticMetadataProvider_Invalid_column=Invalid column index: {0}
JDBC.StoredProcedureResultsImpl_Invalid_parameter_index__0_2=Invalid parameter index: {0}
JDBC.StoredProcedureResultsImpl_ResultSet_cursor_is_after_the_last_row_1=ResultSet cursor is after the last row.
JDBC.stream_closed=The stream already closed
JDBC.Unable_to_read_data_from_stream=Unable to read data from the stream: {0}
JDBC.urlFormat=The required url format is jdbc:teiid:VDBName@mm[s]://server1:port1[,server2:port2][;optional properties]
JDBC.WarningUtil_Failures_occurred=Partial results failures occurred
JDBC.wrong_class=Wrapped object is not an instance of {0}

ProcedureService.procedureServiceTextTableSqlTemplate = SELECT \n\t{0}\nFROM\n\t\
        (EXEC {1}.getTextFiles({2})) AS f, TEXTTABLE(file COLUMNS {3} {4}) AS {5}

ProcedureService.procedureServiceTextInvokeHttpTableSqlTemplate = SELECT \n\t{0}\nFROM\n\t\
        (EXEC {1}.invokeHttp({2})) AS f, TEXTTABLE(TO_CHARS(f.result,''{3}'') COLUMNS {4} {5}) AS {6}
        
ProcedureService.procedureServiceXmlGetTextFilesTableSqlTemplate=SELECT \n\t{0}\nFROM\n\t\
        (EXEC {1}.getTextFiles({2})) AS f, XMLTABLE({3} PASSING XMLPARSE(DOCUMENT f.file) COLUMNS {4}) AS {5}

ProcedureService.procedureServiceXmlInvokeHttpTableSqlTemplate=SELECT \n\t{0}\nFROM\n\t\
        (EXEC {1}.invokeHttp({2})) AS f, XMLTABLE({3} PASSING XMLPARSE(DOCUMENT f.result) COLUMNS {4}) AS {5}
